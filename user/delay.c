

#include "stm32f4xx.h"
//extern uint32_t SystemCoreClock;//возвращает значенин системной частоты
#define F_APB1 84000000//( SystemCoreClock)//16000000  //используетс€ в паузах,верно,если делитель с тактовой равен 1
void delay_ms(uint16_t delay)
{
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
	if ((F_APB1/1000+1)>65536)
		{
	   TIM2->PSC = (F_APB1/2)/1000+1;	//устанавливаем предделитель
     TIM2->ARR = delay*2;	//устанавливаем значение переполнени€ таймера, а значит и значение при котором генерируетс€ —обытие обновлени€ 
	  }
  else
	 {
		 TIM2->PSC = F_APB1/1000+1;	
     TIM2->ARR = delay;
	 }	 
		 TIM2->EGR |= TIM_EGR_UG;	//√енерируем —обытие обновлени€ дл€ записи данных в регистры PSC и ARR
     TIM2->CR1 |= (TIM_CR1_CEN|TIM_CR1_OPM);	//«апускаем таймер записью бита CEN и устанавливаем режим ќдного прохода установкой бита OPM
     while (TIM2->CR1&TIM_CR1_CEN){};//зависаем
}

void delay_us(uint16_t delay)
{
	    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
     TIM2->PSC = F_APB1/1000000+1;	//устанавливаем предделитель
     TIM2->ARR = delay;	//устанавливаем значение переполнени€ таймера, а значит и значение при котором генерируетс€ —обытие обновлени€ 
     TIM2->EGR |= TIM_EGR_UG;	//√енерируем —обытие обновлени€ дл€ записи данных в регистры PSC и ARR
     TIM2->CR1 |= (TIM_CR1_CEN|TIM_CR1_OPM);	//«апускаем таймер записью бита CEN и устанавливаем режим ќдного прохода установкой бита OPM
     while (TIM2->CR1&TIM_CR1_CEN){};//зависаем
}
